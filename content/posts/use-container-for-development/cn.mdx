---
title: "用容器开发"
author: "onichandame"
date: 2019-08-14
---

import {LocalizedLink} from '../../../src/i18n'

<!-- vim-markdown-toc GFM -->

* [一些思考](#一些思考)
* [挑战](#挑战)
  * [Podman](#podman)
  * [防止容器关闭](#防止容器关闭)
  * [缩减镜像大小](#缩减镜像大小)
  * [NOFILE限制](#nofile限制)
  * [UTF-8编码](#utf-8编码)
  * [Windows 10](#windows-10)
    * [Docker引擎](#docker引擎)
    * [HyperV](#hyperv)
  * [Kubernetes](#kubernetes)
    * [集群搭建](#集群搭建)
      * [虚拟机](#虚拟机)
      * [容器PID](#容器pid)
      * [裸机](#裸机)
    * [永久存储](#永久存储)
* [实现](#实现)

<!-- vim-markdown-toc -->

作为一个全职开发者，我经常需要在办公室和家里交替办公。由此导致了一个问题：如何同步家里和办公室里的开发环境？

# 一些思考

最基本的想法是自动化开发环境的配置。作为半个DevOps，脚本是我最信赖的工具。

但是脚本在不同的OS中有不同的写法。因此我必须针对不同的OS编写不同的脚本。这个方法不能保证不同OS上的脚本能同步更新。因此脚本在这个问题中用处不大。

这就是容器有用的地方了。因工作需要，我对容器有一定的了解。容器的以下特性有助于解决此问题：

1. 抽象了一个统一的OS，因此我只需要考虑1个OS。
2. 与宿主机共享文件很方便
3. 在所有主流OS上都能运行

# 挑战

使用容器做开发并不简单。首先我需要用`-it`选项进入容器的TTY界面。然后用`-v`选项将开发文件永久存储在宿主机上。最后用`-p`选项将容器的端口映射到宿主机上。除了这些常见的步骤，一些不常见的问题也需要解决。

以下需要对Linux配置和命令有基本的了解。

## Podman

Podman是一个无daemon的容器运行环境。为绕过SELinux对硬盘读写的限制，需要使用`--security-opt label=disable`选项。

Podman和Docker对容器有不同的定义。Podman不会为每个容器分配一个新IP，因为分配新IP需要root权限。为联通两个非root容器，需要使用一个pod将两个容器包裹起来。[官方文档][pod]提供创造容器和pod的具体方法。[官方文档][pod-com]提供同一pod内不同容器的通信方法。但是，新建pod需要从k8s.gcr.io拉取镜像，在国内由于GFW这不可能。因此必须用一个国内镜像。

`man container-registries.conf`告诉我镜像的配置在`/etc/containers/registries.conf`文件中。这个路径在不同的发行版上可能不一样。在CentOS 8提供的默认配置中使用的是v1版本。但是镜像配置只在v2版本中可用，因此必须将配置转换为v2版本：

```text
unqualified-search-registries = ['docker.io', 'registry.access.redhat.com', 'registry.fedoraproject.org', 'registry.centos.org']

[[registry]]
prefix="k8s.gcr.io"
location="k8s.gcr.io"

[[registry.mirror]]
location="registry.cn-hangzhou.aliyuncs.com/google_containers"
```

感谢[此问题][pod-mirror]

在删除旧配置并添加新配置后，可以用阿里云镜像创造pod。

在pod内的容器无法直接与host通过port mapping通信，因此必须在创建pod时就将port mapping设置好。

```bash
podman pod create -p 30000:3000
```

## 防止容器关闭

容器都会在PID 1的进程退出时自动关闭。对使用`docker run -it --rm`与逆行的无状态容器来说这不是问题。但在kubernetes中，所有容器都需要在后台运行并用`kubectl exec -it`进入容器进行交互。

为永久运行一个容器，有两种方法：

1. `tail -f /dev/null`
2. `bash`

第一个选择的问题在于它无法对SIGKILL/SIGINT正常响应，因此pod将在*Terminating*状态下卡死。

第二个选择的问题在于它需要一个pseudo-tty以防止进程关闭。

综合考虑，`tail`方法的问题无法找到一个简单的解决方法。但`bash`方法的问题可以用提供pseudo-tty解决。

## 缩减镜像大小

最终镜像的大小主要取决于Linux distro的选择。传统的distro如CentOS没有针对容器化做优化，因此基于它的镜像的大小都很容易失控。我选择Alpine 3。基于Alpine 3的镜像大概在1.8 GB左右，但基于CentOS的版本超过了3 GB。

## NOFILE限制

在开发前端时，开发服务器需要监控许多源文件的变动，在源文件很多时，经常会超出默认的打开文件数量限制。

文件数量限制由一个硬限制和一个软限制组成。当超过软限制时，用户会收到警告；当硬限制被突破时，系统会报错。因此两种限制都需要提升。

我的解决方案是提升宿主机的NOFILE限制，容器会自动继承宿主机的配置。详细步骤在<LocalizedLink to={'/post/ulimit'}>此文</LocalizedLink>中。

## UTF-8编码

为提升performance，大多数基础镜像都只支持ASCII以尽量缩减大小。这在宿主机支持UTF-8且容器直接将字符输出至屏幕时没有问题。但当容器内使用tmux时，tmux先将字符解码，再将解码失败的乱码发送至屏幕。

解决的第一步是在容器中添加特殊字符支持。我需要添加简中，因此我安装了`glibc-langpack-zh`。运行`locale -a`以检查是否安装成功。

最后一步是选择默认编码。我在bashrc中添加了`export LANG="zh_CN.UTF-8"`和`export LC_ALL="zh_CN.UTF-8"`。

## Windows 10

Docker最初是为Linux设计的，因此在Windows上运行Docker总会出问题。本节我记录了所有在Windows 10上遇到的问题及其解决方案。

### Docker引擎

当写下这一句时，Docker Desktop主要提供2个引擎：HyperV（旧引擎）和WSL 2。

HyperV就是一个传统的VM hypervisor，Docker用它建立一个跑docker后台的虚拟机。

而WSL 2是一个深度集成的Linux内核，它比其它方案更快。因此我选择使用它。

第一步是安装WSL 2，点击[此处][wsl]获取官方教程。

安装完毕WSL 2后，勾选Docker Desktop的General settings中的**Use the WSL 2 based engine**选项，然后重启docker后台让更改生效。**注意：重启后台后旧后台上的所有镜像都会删除！**

当前版本的WSL 2有一个恶性bug。如果你启动一个基于WSL 2的Linux发行版时，显示错误信息**the attempted operation is not supported for the type of object referenced.**，这意味着WinSock导致WSL 2崩溃了。基于[此问题][winsock]，以管理员模式运行`netsh winsock reset`可以永久解决这个问题。

### HyperV

无论选择使用HyperV还是WSL 2，HyperV服务都必须被启用。但是微软做了个非常蠢的设定，在HyperV被启用后，BIOS里的虚拟化会被关掉。因此在每次启用HyperV后，都必须手动进入BIOS启用虚拟化。

感谢[此问题][hyperv]

## Kubernetes

我的生产环境是kubernetes，云端和本地都有。因此我需要配置一个符合生产环境的开发环境。

使用kunernetes作为开发环境，很多事情都要重新考虑。

### 集群搭建

安装kubernetes集群并不像Docker Desktop那样简单。官方推荐使用[minikube][minikube]配置开发环境。但我选择用[kind][kind]，因为它对跨平台的支持比[minikube][minikube]更好，更统一。

[kind][kind]提供一个可执行程序用以管理集群，可以根据官方文档的指示进行安装。

身处中国大陆，如gcr registry之类的谷歌服务都不可用。因此必须使用镜像registry来绕过限制。[kind][kind]可以从yaml文件中获取设置，就像k8s从yaml文件获取deployment配置一样。为此，我创建了[一个配置文件](https://github.com/onichandame/docker-dev/blob/master/kube/cluster.yaml)。

有一个需要注意的点是`nodes.role.extraMounts`负责将宿主机上的一个路径映射至worker node上。如果不需要persistent storage可以将其删除。

将配置文件保存在cluster.yaml内，就可以用以下命令启动集群：

```bash
kind create cluster --config git/kube/cluster.yaml
```

# 实现

源项目的结构如下所示：

![struc](/image/container-development-structure.png)

Dockerfile是构建最终镜像的指令。

files目录下包含所有必须的配置文件，如bashrc和vimrc等。

[点此][src]获取源文件

[点此][hub]获取镜像

[src]: https://github.com/onichandame/docker-dev/
[hub]: https://hub.docker.com/repository/docker/onichandame/docker-dev
[wsl]: https://docs.microsoft.com/en-us/windows/wsl/wsl2-install
[winsock]: https://github.com/microsoft/WSL/issues/4177
[hyperv]: https://answers.microsoft.com/en-us/windows/forum/all/resolving-wslregisterdistribution-error-0x80370102/412cf42b-1424-444c-bb95-4aa2b5fe5eaf
[pod]: https://developers.redhat.com/blog/2019/01/15/podman-managing-containers-pods/
[pod-com]: https://www.redhat.com/sysadmin/container-networking-podman
[pod-mirror]: https://github.com/containers/libpod/issues/5764
[minikube]: https://minikube.sigs.k8s.io/
[kind]: https://kind.sigs.k8s.io/
